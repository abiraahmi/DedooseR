---
title: "Introduction to DedooseR - let's get cleaning!"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to DedooseR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r setup}
library(DedooseR)
library(readxl)

# Look for private test file in inst/raw_data
private_path <- system.file("raw_data", "test_data.xlsx", package = "DedooseR")

if (file.exists(private_path)) {
  data <- readxl::read_xlsx(private_path)
} else {
  message("Private file not found — using synthetic demo dataset instead.")
  data("excerpts_demo", package = "DedooseR")
  data <- excerpts_demo
}

head(data)
```

Welcome to DedooseR! **DedooseR** is an R package that connects with 
[Dedoose](https://www.dedoose.com/) to support the analysis of qualitative data.
It was built to help researchers streamline workflows, explore qualitative data 
flexibly,and conduct qualitative coding and analysis with rigor. 

This package can do a few nifty things, but let's get started with cleaning and 
labelling our data. 

The *clean_data* function does a few cool things:
* it makes variable names user-friendly
* it generates a code-book, with all "code" variables starting with "c_"
* it allows us to list our coder preferences

```{r}
# Locate example file inside inst/raw_data
filepath <- system.file("raw_data", "test_data.xlsx", package = "DedooseR")

if (file.exists(filepath)) {
  excerpts <- readxl::read_xlsx(filepath)
} else {
  message("Private file not found — using synthetic demo dataset instead.")
  data("excerpts_demo", package = "DedooseR")
  excerpts <- excerpts_demo
}

# To run this function you need to call in two things: (1) your raw data and (2) your coder preferences

# Often, we have 2 coders blind-coding every transcript. This function assigns 
# coder ranks according to a preferred coders vector and, for every media title, 
# selects the coder with the highest rank so we avoid double-counts. If you have 
# single coders/media title, then list all of them!
# Preferred coder order
preferred_coders <- c("a", "l", "i", "r", "s", "v", "c", "n", "k")

# Run cleaning function
cleaned <- clean_data(
  excerpts,
  preferred_coders,
  rename_vars = list(memo_destigmatization = "...274"),  # optionally rename variables
  relabel_vars = list(title = "Memo: Destigmatization")  # optioanlly relabel variables
)

# Extract cleaned dataset
data <- cleaned$data

# And a codebook with variable names, labels and character types so we have a
# clearer understanding of all the data we have to play with. 
codebook <- cleaned$codebook

```

As we iteratively refine our codebook, we often decide to collapse or merge
some codes into others. The *merge_codes* function can help us do this, while 
allowing us to relabel the variables:

```{r}
data <- merge_codes(data, list(
  c_belonging_connectedness = c(
    "c_sense_of_belonging",
    "c_sense_of_belonging_others", "c_sense_of_belonging_self",
    "c_sense_of_connectedness", "c_sense_of_connectedness_family",
    "c_sense_of_connectedness_peers", "c_sense_of_connectedness_staff"
  ),
  c_salience = c(
    "c_salience",
    "c_salience_personal_development",
    "c_salience_relevance"
  )
))
```

"Hey, remember when you spoke to 50 kids 5 years ago about program impact. 
Do you remember if the *Long-term impact* theme captured just academic 
impact or emotional, too?"

I do not. But this function let's us easily filter through our rich data to
help us answer that:

```{r}
# Before visualizing excerpts, let's make sure the 'excerpt' column exists.
# This prevents vignette build errors on CRAN when private data aren't shipped.
if ("excerpt" %in% names(data)) {
  try(
    view_excerpts(data),
    silent = TRUE
  )
} else {
  message("Skipping view_excerpts(): no 'excerpt' column found in demo data.")
  message("Tip: This chunk runs fully when the private test_data.xlsx is available.")
}
```



